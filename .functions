#!/bin/bash

# Kill a process based in the number of the TCP Port.
killport() {
  PORT_NUMBER=$1
  lsof -i tcp:"${PORT_NUMBER}" | awk 'NR!=1 {print $2}' | xargs kill
}

# git tag and push
# gtp <tag>
gtp() {
  command git tag -am "$1" "$1" && \
  command git push && \
  command git push --tags
}

# delete a git tag
gtd() {
  command git tag -d "$1"
  command git push origin :refs/tags/"$1"
  command git tag -d "$1"
}

# delete a git branch
gbd() {
  command git branch -D "$1"
  command git push origin --delete "$1"
}

# See the contributors of a git repository
gcredits() {
  command git shortlog -sn
}

gtoday() {
  command git diff --shortstat "@{0 day ago}"
}

# open all changed files (that still actually exist) in the editor
geditor() {
  $EDITOR $(git status --porcelain | awk '{print $2}')
}

# Empty Trash
function emptytrash() {
  sudo rm -rfv /Volumes/*/.Trashes
  sudo rm -rfv ~/.Trash
  # clear Appleâ€™s System Logs to improve shell startup speed
  sudo rm -rfv /private/var/log/asl/*.asl
}

function cl () {
  builtin cd "$@" && ls
}

# Create a new directory and enter it
function mc() {
  mkdir -p "$@" && cd "$@"
}

# find shorthand
function f() {
  find . -name "$1"
}

# Create a data URL from a file
function dataurl() {
  local mimeType=$(file -b --mime-type "$1")
  if [[ $mimeType == text/* ]]; then
    mimeType="${mimeType};charset=utf-8"
  fi
  echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Create a git.io short URL
function gitio() {
  if [ -z "${1}" -o -z "${2}" ]; then
    echo "Usage: \`gitio slug url\`"
    return 1
  fi
  curl -i http://git.io/ -F "url=${2}" -F "code=${1}"
}


# A better git clone
# clones a repository, cds into it, and opens it in my editor.
#
# Based on https://github.com/stephenplusplus/dots/blob/master/.bash_profile#L68 by @stephenplusplus
#
# Note: subl is already setup as a shortcut to Sublime. Replace with your own editor if different
#
# - arg 1 - url|username|repo remote endpoint, username on github, or name of
#           repository.
# - arg 2 - (optional) name of repo
#
# usage:
#   $ clone things
#     .. git clone git@github.com:addyosmani/things.git things
#     .. cd things
#     .. subl .
#
#   $ clone yeoman generator
#     .. git clone git@github.com:yeoman/generator.git generator
#     .. cd generator
#     .. subl .
#
#   $ clone git@github.com:addyosmani/dotfiles.git
#     .. git clone git@github.com:addyosmani/dotfiles.git dotfiles
#     .. cd dots
#     .. subl .

function clone {
  # customize username to your own
  local username="kikobeats"

  local url=$1;
  local repo=$2;

  if [[ ${url:0:4} == 'http' || ${url:0:3} == 'git' ]]
    then
    # just clone this thing.
    repo=$(echo $url | awk -F/ '{print $NF}' | sed -e 's/.git$//');
  elif [[ -z $repo ]]
    then
    # my own stuff.
    repo=$url;
    url="git@github.com:$username/$repo";
  else
    # not my own, but I know whose it is.
    url="git@github.com:$url/$repo.git";
  fi

  git clone $url $repo && cd $repo && subl .;
}

# Copy w/ progress
cp_p () {
  rsync -WavP --human-readable --progress $1 $2
}


# Test if HTTP compression (RFC 2616 + SDCH) is enabled for a given URL.
# Send a fake UA string for sites that sniff it instead of using the Accept-Encoding header. (Looking at you, ajax.googleapis.com!)
function httpcompression() {
  encoding="$(curl -LIs -H 'User-Agent: Mozilla/5 Gecko' -H 'Accept-Encoding: gzip,deflate,compress,sdch' "$1" | grep '^Content-Encoding:')" && echo "$1 is encoded using ${encoding#* }" || echo "$1 is not using any encoding"
}

# Syntax-highlight JSON strings or files
function json() {
  if [ -p /dev/stdin ]; then
    # piping, e.g. `echo '{"foo":42}' | json`
    python -mjson.tool | pygmentize -l javascript
  else
    # e.g. `json '{"foo":42}'`
    python -mjson.tool <<< "$*" | pygmentize -l javascript
  fi
}

# prune a set of empty directories
function prunedir () {
   find $* -type d -empty -print0 | xargs -0r rmdir -p ;
}

# take this repo and copy it to somewhere else minus the .git stuff.
function gitexport(){
  mkdir -p "$1"
  git archive master | tar -x -C "$1"
}

# get gzipped size
function gz() {
  echo "orig size    (bytes): "
  cat "$1" | wc -c
  echo "gzipped size (bytes): "
  gzip -c "$1" | wc -c
}

# All the dig info
function digga() {
  dig +nocmd "$1" any +multiline +noall +answer
}

# `o` with no arguments opens current directory, otherwise opens the given
# location
function o() {
        if [ $# -eq 0 ]; then
                open .
        else
                open "$@"
        fi
}

# Launch installed browsers for a specific URL
# Usage: browsers "http://www.google.com"
function browsers(){
  chrome "$1"
  opera "$1"
  firefox "$1"
  safari "$1"
}

function static() {
  browser-sync start --server --files "index.html, **/*.(css|js|md)"
}

function openurl(){
  if [ $2 ]
  then
    url=$1"&host_ports=$2"
  fi
  open -a google\ chrome ${url}
}

function ia() {
  for FILE in "$@"
  do
    if [ -e "$FILE" ]; then
      open -a "iA Writer" "$FILE"
    else
      touch "$FILE"
      open -a "iA Writer" "$FILE"
    fi
  done;
}
# direct it all to /dev/null
function devnull() {
  "$@" >/dev/null 2>&1
}

# turn that video into webm.
# brew reinstall ffmpeg --with-libvpx
function webmify() {
	ffmpeg -i "$1" -vcodec libvpx -acodec libvorbis -isync -copyts -aq 80 -threads 3 -qmax 30 -y "$2" "$1.webm"
}

function mp4() {
  ffmpeg -i "$1" -vcodec libx264 -preset veryfast "$1.mp4"
}